## 前言
	作者 Sam Newman
## 1.微服务介绍
	Microservices
	
### 微服务优势

	* 技术异构：各微服务可以使用不同的技术来实现
		将在第二、四章讨论
	* 易伸缩
		将在第十一章讨论
	* 为各微服务分配不同的资源，以更大的利用现有资源
	* 易部署：更改某一个服务后，只需发布这一个服务
		将在第六章讨论
	* 开发团队组织更灵活
		将在第十章讨论
	* 可复用：微服务可以被桌面端、网页端、移动端、可穿戴设备调用
		将在第五章讨论
	* 易升级与替换
	
### 讨论下面向服务构架（SOA）
	SOA能解决单体应用中的一些痛点，但是其致命的缺点如下：
	
	* 即使花大量时间已未免会真正明白SOA的意义
	* 之间通讯协议复杂
	* 中间件太多
	* 不易拆分业务
	
### 再讨论下其它类似技术
	* 共享库技术
	* 模块化技术

### 微服务也不是银弹，面临的挑战
	* 分布式部署很复杂
	* 监控、测试很复杂
	* 如何架构才能保证系统的可伸缩性
	* 分布式事务处理
	* CAP定理困扰
	> CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼
		
## 2.架构师的扮演的角色及承担的工作
	The Evolutionary Architect

### 不正确的比较
	* 因为其它领域的架构师的经验更易积累，所以跟其它领域的架构师比较，要成为一名合格的架构师或工程师更难；
	* 为了获得社会的承认，我们借用了架构师这个称呼；但是在软件一次又一次的崩溃中，让我们名声变差；
	* 我们自己要重新定义这个角色

### 软件架构师应该的样子
> 做针对实际情况不断的对自己系统进行调整
> 我们的工作更像乡镇规划师：关注布局，而非细节

### 微服务架构师应该关注什么
* 微服务的边界，服务拆分，服务间的关系是怎样的
* 确定服务间的通讯协议
* 统一数据存储标准：使用哪些数据库

### 设计流程
确定目标->确定原则->具体措施
拿一个我们客户的例子来演示：
确定目标：
	* 能支撑高并发业务
	* 能加入新实例
	* 能更新实例
确定原则：
…………
	
### 必备标准
* 监控：
	为了确定各服务的健康状态，有两种方式收集状态：1、服务主动上报；2、主动去各服务收集；无论采用哪种，都要确保传递的数据是标准化的；
* 接口：
	确定各接口要用到的“数字”标准：用于分页、版本等；不要每个接口自己搞一套数字标准；
* 安全：
	
### 代码管理
	进行代码管理，保证代码风格最好的方式是提供示例与模板；
	* 示例比文档更有用

### 技术债
	有两方便的原因：
	* 由于时间原因，我们经常会偷懒处理有的逻辑
	* 各系统的版本没有统一更新
从长远角度来看，我们迟早会为此付出代价；所以架构师要作一个平衡；

### 灵活处理
	* 虽然确定了原则，但还是针对实际情况处理；如果变动的多，那就需要更改原则
	* 要给每个开发微服务的团队充分自由
	
### Governance and Leading from the Center

### 团队建设
	* leader 不仅仅要关闭团队的技术成长，还要帮助团队成员更好的了解自己的个性、更好的塑造自己个性与思想
	* 如何帮助团队成长不是本书讨论的重点，但有一点可以肯定，相比作单体系统开发，微服务团队成员能够获得的东西更少
	* 所以，最好能成员全权负责一个服务的开发 

### 架构师总结
	* 确定系统的技术愿景
	* 明确自己的确定对技术团队与客户的影响
	* 能促使团队全力合作
	* 面对突发情况，灵活处理，及时调整策略
	* 在统筹安排与成员自主之间作好平衡
	* 
	
## 3.为每个服务建模
	How to Model Services
> 本章讲解如何定义各个服务的边界
### 介绍MusicCorp
	结合例子可以更好的阐述概念
	> MusicCorp：是一个音乐公司
	> 这个例子没看懂
	
### 如何构建一个好的微服务
	尽管微服务有很多其它原则，但这里提到的两个是基础
	* 低耦合
		> 方便随时切换，这是微服务根本
		当一个服务变动后，也需要调用它的接口也作更改，这就是典型的高耦合;我们将在第四章中详细讨论
		>严格限定各服务间的通讯标准，就是为了降低耦合
		
	* 高聚合
		相关的逻辑处理放到一起，当改动了一个微服务的某个逻辑后，最好只改动最少的地方；也只更新一个服务；不要一个服务改动了，还要同时改动其它微服务。
		
	基于以上两点，所以我们需要确定服务边界。
		
### 微服务边界的概念
> 感觉没有讲到点子上
	* 作者很喜欢(领域驱动设计)Domain-Driven Design中关于边界的定义；
	* 边界清晰了，功能划分才能清晰
	
#### 每个微服务该提供哪些接口，该暴露什么东西
	上面提到的MusicCorp这个例子中，财务部就不用了解仓储部内部的细节
	* 微服务内部不同的模块提供不同的功能
#### 将微服务内部划分成各个模块
	没有理解boundaries context 这个词，导致对本章节的理解不透
	* 当想清楚每个模块应该提供什么接口时，我们就避免高偶合的这个圬
	* 当您成为一个微服务的技术专家的时候，才可以跳过划分微服务内部模块这个步骤，而直接去切分服务

#### 过早的上微服务
	以我在ThoughtWorks工作时遇到的例子来说。
	我们团队之前开发过一个基于微服务的系统叫Go-CD；后来需要开发另一个领域的新系统SnapCI，于是我们借鉴了之前的经验对其进行服务边界界定，快速的完成了SnapCI的微服务的开发。
	几个月后，我们意识到当初那样划分服务的错误，因为这导致了我们经常要大批量的修改各微服务。最后，我们团队决定将微服务系统融合成单体系统，以便我们能更好的明白各个业务边界。
	一年后，在我们对业务及服务边界很熟悉后，我们团队又将这个单体系统变成微服务系统。
	过早的上微服务是有风险的，特别当您对业务不熟悉的时候。所以将一个单体系统转化成微服务，比直接上微服务要容易的多。

### 业务功能
	我们在划分业务边界的时候，应该从模块的能提供什么样的功能这个方面来思考，而不是从模块需要什么数据来这个方面思考。
	举个例子：仓储业务功能是提供仓储物品清单，而财务业务功能是月末时提供对帐清单或为新入职同事作工资表。从业务功能出发思考需要什么数据。
	所以在为每个服务建模的时候，先想清楚：业务功能是什么，再说 需要什么数据
	
### 海龟背地球原则(Turtles All the Way Down )
	海龟背地球，海龟下面是什么呢？是由另一只海龟背着，如此反复；那么此原则对于切分业务有何影响呢？
	* 划分业务时，粒度先粗点，再细分
	* 举个例子：确定了仓储业务后，再把仓储业务划分为订单处理业务、库存管理业务、货物接收业务。
	* 针对这种嵌套的业务切分，有两种方式：一是把各子业务隐藏于仓储服务中，如图 **3-2**，二是将各子业务划分为独立的服务，如图 **3-3**
	* 至于应该选择哪种切分方式，没有必需要准则，但是可以视开发团队组织情况而定：如果子业务都是同一个团队开发，那么采取第一种方式；如果是单独开发，那么采取第二种方式；关于团队组织我们将在第十章讨论
	* 但是第一种切分方式更加体系化，从而方便测试。关于测试我们将在第七章讨论	
->![3-2](chart/3-2.png?raw=true)<-	
![3-3](chart/3-3.png)
### 沟通业务概念 
	
	
### 技术边界
	
### 总结
	
	
## 4.整合
	integration
> 本章介绍了在什么时候开始整合，并介绍了如何避免常见的坑的方法

## 5.切分与改造单体应用
	Splitting the Monolith
> 本章介绍了如何将一个复杂的单体应用进行微服务改造

## 6.发布

## 7.测试

## 8.监控

## 9.安全

## 10.康威定律与系统设计
	Conway’s Law and System Design
	
## 11.如何大规模部署微服务
	Microservices at Scale
	
## 12.总结
